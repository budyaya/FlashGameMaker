/** * Realistic Floating Soap Bubbles * --------------------- * VERSION: 1.0 * DATE: 8/25/2010 * AS3 * UPDATES AND DOCUMENTATION AT: http://www.FreeActionScript.com **/package utils.freeactionscript{	import com.greensock.easing.Linear;	import com.greensock.TweenMax;	import flash.display.Bitmap;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;		import com.greensock.TimelineLite;	import com.greensock.easing.Sine;		/*	 * MovingBubble creates a Bubble with random motion.	 * The random motion is a product of three separate motions:	 * rotation, up and down motion along the y axis and linear motion	 */	public class MovingBubble extends Sprite	{		private var _bubble:Bubble;		private var _rotator:Sprite;		private var _initializer:MovingBubbleInitializer;		private var _timeline:TimelineLite;		private var _rotationTween:TweenMax;		private var _linearTween:TweenMax;				private var _linearDuration:Number = 4;		private var _maxLinearDisplacement:int = 100;		private var _minAmplitude:int = 50;		private var _maxAmplitude:int = 150;		private var _rotationDurationMin:Number = 12;		private var _rotationDurationMax:Number = 20;		private var _oscillationDurationMin:Number = 2;		private var _oscillationDuratiomMax:Number = 4;		private var _linearMotionDelay:Number = 5;				private var _dx:int;		private var _dy:int;		private var _currentRotation:int = -1;		private var _started:Boolean = false;		private var _popping:Boolean = false;				public function MovingBubble(startPoint:Point)		{			_bubble = new Bubble;			_rotator = new Sprite;			_initializer = new MovingBubbleInitializer(this, startPoint);						_rotator.addChild(_bubble);			addChild(_rotator);						_rotator.rotation = Math.random() * 360;			_bubble.rotation = -_rotator.rotation;						_dx = Math.random() * _maxLinearDisplacement * 2 - _maxLinearDisplacement;			_dy = Math.random() * _maxLinearDisplacement * 2 - _maxLinearDisplacement;		}				public function get started():Boolean		{			return _started;		}				public function get popping():Boolean		{			return _popping;		}				public function get radius():Number		{			return _bubble.radius;		}				/*		 * Starts the bubble's animation from the controlPoint		 */		public function init(controlPoint:Point, endPoint:Point):void		{			_started = true;			_initializer.start(controlPoint, endPoint);			play();			TweenMax.delayedCall(_linearMotionDelay, startLinearMotion);		}				/*		 * Starts the bubble's random motion.		 */		public function play():void		{			_started = true;						if (null == _timeline) startOscillation();			else _timeline.play();						if (null == _rotationTween) startRotation();			else _rotationTween.play();						//if (null == _linearTween) startLinearMotion();			//else _linearTween.play();		}				public function stop():void		{			_timeline.stop();			_rotationTween.pause();			_linearTween.pause();		}				public function pop():void		{			_popping = true;			_bubble.addEventListener(Event.COMPLETE, onPopComplete,false,0,true);			_bubble.pop();		}				public function getGlobalPosition():Point		{			return _bubble.localToGlobal(new Point(0, 0));		}				public function destroy():void		{			if (null != _timeline)			{				_timeline.kill();				_timeline = null;			}			if (null != _rotationTween)			{				_rotationTween.kill();				_rotationTween = null;			}			if (null != _linearTween)			{				_linearTween.kill();				_linearTween = null;			}						TweenMax.killTweensOf(_rotator);			TweenMax.killTweensOf(_bubble);			TweenMax.killTweensOf(this);			TweenMax.killDelayedCallsTo(startLinearMotion);						_currentRotation = -1;						_bubble.removeEventListener(Event.COMPLETE, onPopComplete);			_bubble.destroy();						_initializer.destroy();			_initializer = null;		}				/*		 * If we don't use linear motion, the bubbles will hang around in one region forever.		 */		private function startLinearMotion():void		{			if (null != _linearTween) _linearTween.kill();						_linearTween = TweenMax.to(this, _linearDuration, {x: x + _dx, y: y + _dy, ease: Linear.easeNone, onComplete: startLinearMotion});		}				private function startOscillation():void		{			if (null != _timeline) _timeline.kill();						_timeline = new TimelineLite({onComplete: onOscillationComplete});						var amplitude:int = _minAmplitude + Math.random() * (_maxAmplitude - _minAmplitude);			_timeline.append(new TweenMax(_bubble, getRandomOscillationDuration(), {y: amplitude, ease: Sine.easeOut}));			_timeline.append(new TweenMax(_bubble, getRandomOscillationDuration(), {y: 0, ease: Sine.easeIn}));						amplitude = _minAmplitude + Math.random() * (_maxAmplitude - _minAmplitude);			_timeline.append(new TweenMax(_bubble, getRandomOscillationDuration(), {y: -amplitude, ease: Sine.easeOut}));			_timeline.append(new TweenMax(_bubble, getRandomOscillationDuration(), {y: 0, ease: Sine.easeIn}));		}				private function startRotation(randomize:Boolean = false):void		{			if (null != _rotationTween) _rotationTween.kill();						if ( -1 == _currentRotation)			{				_currentRotation = 360;				randomize = true;			}						if (true == randomize)			{				var multiplier:int = 1;				if (.5 < Math.random()) multiplier = -1;								_currentRotation *= multiplier;			}						var duration:Number = _rotationDurationMin + Math.random() * (_rotationDurationMax - _rotationDurationMin);			_rotationTween = TweenMax.to(_rotator, duration, {rotation: _currentRotation, ease: Linear.easeNone, onComplete: startRotation, onUpdate: onRotationUpdate});		}				private function onOscillationComplete():void		{			// Only change direction of rotation when the oscillator is at 0.			startRotation(true);			startOscillation();		}				private function onRotationUpdate():void		{			_bubble.rotation = -_rotator.rotation;		}				private function getRandomOscillationDuration():Number		{			return _oscillationDurationMin + Math.random() * (_oscillationDuratiomMax - _oscillationDurationMin);		}				private function onPopComplete(e:Event):void		{			_bubble.removeEventListener(Event.COMPLETE, onPopComplete);			dispatchEvent(new Event(Event.COMPLETE));		}	}}