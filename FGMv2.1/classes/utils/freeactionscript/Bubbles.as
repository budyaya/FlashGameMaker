/** * Realistic Floating Soap Bubbles * --------------------- * VERSION: 1.0 * DATE: 8/25/2010 * AS3 * UPDATES AND DOCUMENTATION AT: http://www.FreeActionScript.com **/package utils.freeactionscript{	import com.greensock.TweenMax;		import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;		public class Bubbles extends Sprite	{		private var _bubbles:Array;				private var _maxBubbles:int = 40;				private var _minX:int = 23;		private var _minY:int = 50;		private var _width:int = 500;		private var _height:int = 350;		private var _startPoint:Point = new Point(275, 375);		private var _controlPoint:Point = new Point(275, 150);				public function Bubbles($offset:Point=null,$width:Number=500, $height:Number=350, $maxBubbles:Number=40){			_width = $width;			_height = $height;			_maxBubbles = $maxBubbles;						x-=_width/2 + _minX;			y-=_height - _minY;			if($offset){				x+=$offset.x;				y+=$offset.y;			}			_bubbles = new Array;			var i:int = 0;			var bubble:MovingBubble;			for (i; i < _maxBubbles; i++)			{				bubble = createRandomBubble();				bubble.visible = false;				_bubbles.push(bubble);				addChild(bubble);			}		}				public function play():void		{			var delay:Number = 0;						var bubble:MovingBubble;			for each (bubble in _bubbles)			{				TweenMax.delayedCall(delay, showBubble, [bubble]);				delay += .05;			}			addEventListener(Event.ENTER_FRAME, onBubblesEnterFrame,false,0,true);		}				public function stop():void		{			var bubble:MovingBubble;			for each (bubble in _bubbles)			{				bubble.stop();			}			removeEventListener(Event.ENTER_FRAME, onBubblesEnterFrame);		}				public function destroy():void		{			var bubble:MovingBubble;			for each (bubble in _bubbles)			{				destroyBubble(bubble);			}			removeEventListener(Event.ENTER_FRAME, onBubblesEnterFrame);						TweenMax.killDelayedCallsTo(showBubble);		}				private function showBubble(bubble:MovingBubble):void		{			bubble.visible = true;			bubble.init(_controlPoint, getRandomPoint(bubble.radius, bubble.radius));		}				private function createRandomBubble():MovingBubble		{			var bubble:MovingBubble = new MovingBubble(_startPoint);			return bubble;		}				private function destroyBubble(bubble:MovingBubble):void		{			removeChild(bubble);			bubble.removeEventListener(Event.COMPLETE, onBubblePopComplete);			bubble.destroy();		}				private function getRandomPoint(bubbleWidth:int, bubbleHeight:int):Point		{			return new Point(_minX + Math.random() * (_width - bubbleWidth), _minY + Math.random() * (_height - bubbleHeight));		}				private function onBubblesEnterFrame(e:Event):void		{			var localPoint:Point = localToGlobal(new Point(0, 0));						var bubble:MovingBubble;			var bubblePoint:Point;			var i:int;			var l:int = _bubbles.length;			for (i; i < l; i++)			{				bubble = _bubbles[i];				if (true == bubble.popping || false == bubble.started) continue;								bubblePoint = bubble.getGlobalPosition();								if (					localPoint.x + _minX > bubblePoint.x - bubble.radius ||					localPoint.x + _minX + _width < bubblePoint.x + bubble.radius ||					localPoint.y + _minY > bubblePoint.y - bubble.radius ||					localPoint.y + _minY + _height < bubblePoint.y + bubble.radius				)				{					bubble.addEventListener(Event.COMPLETE, onBubblePopComplete,false,0,true);					bubble.pop();				}			}		}				private function onBubblePopComplete(e:Event):void		{			var bubble:MovingBubble = MovingBubble(e.target);			var i:int = 0;			var l:int = _bubbles.length;			var deleteIndex:int = -1;			for (i; i < l; i++)			{				if (_bubbles[i] == bubble)				{					deleteIndex = i;					break;				}			}			if ( -1 != deleteIndex)			{				_bubbles.splice(deleteIndex, 1);			}			destroyBubble(bubble);						// Create a new bubble.			bubble = createRandomBubble();			_bubbles.push(bubble);			addChild(bubble);			bubble.init(_controlPoint, getRandomPoint(bubble.radius, bubble.radius));		}	}}